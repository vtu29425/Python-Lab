def find_optimal_strategy(cards): 
n = len(cards) 
# Create a memoization table to store subproblem results 
dp = [[0] * n for _ in range(n)] 
# Fill the table for subproblems of increasing sizes 
for length in range(1, n+1): 
for i in range(n-length+1): 
j = i + length - 1 
# If only one card is left, the player takes it 
if i == j: 
dp[i][j] = cards[i] 
else: 
# Choose the best of two choices: 
# 1. Take the left card, and the opponent plays optimally on the remaining (i+1, j) 
# 2. Take the right card, and the opponent plays optimally on the remaining (i, j-1) 
take_left = cards[i] - dp[i+1][j] 
take_right = cards[j] - dp[i][j-1] 
dp[i][j] = max(take_left, take_right) 
# dp[0][n-1] will have the optimal score difference for the first player 
return (dp[0][n-1] + sum(cards)) // 2  # First player's maximum possible score 
# Example case 
cards = [3, 9, 1, 2] 
print("First player's optimal score:", find_optimal_strategy(cards)) 
